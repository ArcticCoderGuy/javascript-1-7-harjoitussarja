# Teht√§v√§ 1a "paja"-sanahaku merkkijonosta

Teht√§v√§ss√§ 1a etsit√§√§n merkkijonosta sana "paja" ja siirret√§√§n se uuteen muuttujaan, jos se l√∂ytyy. Kirjoitan ensin pseudokoodin, koska haluan ymm√§rt√§√§ **MIKSI** asiat toimivat, ei pelk√§st√§√§n **MITEN**.

T√§m√§ ajattelutapa hidastaa alussa, mutta tekee ty√∂st√§ nopeampaa ja laadukkaampaa my√∂hemmin aivan kuten miss√§ tahansa asiassa.



 Pseudokoodi 

1. Asetetaan alkuper√§inen merkkijono, esimerkiksi     
   "asuntokionapajaa"`.  
   Koska arvo ei muutu, k√§ytet√§√§n `const` ‚Üí muuttuja nimelt√§ `mystinenSana`.

2. Alustetaan uusi muuttuja nimelt√§ `uusiMuuttuja`, johon 
   sijoitetaan tulos, **jos** ehto t√§yttyy. T√§m√§ on hyv√§ esimerkki muuttujasta, joka voi muuttua, joten k√§ytet√§√§n `let`.

3. Tarkistetaan ja tehd√§√§n logiikkalause:
   - Esiintyyk√∂ sana `"paja"` alkuper√§isess√§ merkkijonossa `mystinenSana`?

   - Jos l√∂ytyy:
     - Siirret√§√§n `"paja"` muuttujaan `uusiMuuttuja`
     - Tulostetaan molemmat merkkijonot konsoliin
   - Jos ei l√∂ydy:
     - Tulostetaan `"Sanaa ei l√∂ytynyt"` konsoliin
     - Ohjelman suoritus p√§√§ttyy

---

 Miksi miksi ?

Merkkijonojen k√§sittely on yksi t√§rkeimmist√§ ohjelmoinnin perusteista. Pseudokoodin avulla hahmotan selke√§sti mit√§ tavoitellaan, ilman ett√§ j√§√§n kiinni syntaksin yksityiskohtiin.  
Kun ajattelu toimii, koodin kirjoitus on pelkk√§√§ ilmaisua.

// if (originalString.includes("paja") !==-1) 
Kun asiaa tutkin niin "paljastui" ett√§ t√§h√§n ei ole mt√§√§n muuttujaa sellaisenaan saatavana vaan on √§lytt√§v√§ rakentaa sopiva logiikkaehto. Logiikkaehtoon k√§ytin kyll√§ AI:ta, koska en ole viel√§ niin hyv√§, ett√§ voisin itse johtaa noita logiikkalauseita kun asia on kuitenkin uusi. Opittiin kuitenkin taas uutta ja saatiin koodia aikaiseksi sek√§ omaa osaamista kehitetty√§.

Koko roskan ajoin sitten Node.js:ll√§ jonka , koska se oli niin helppoa ja nopeaa. Otin https://nodejs.org/en ja asensin sen ja kun kone herjasi ett√§ "niit√§ lupia ei sitten kyll√§ ollutkaan" niin ajoin sitten powershell:ss√§ "Set-ExecutionPolicy RemoteSigned -Scope CurrentUser" ja sitten toimii.

Ajettin Node.js:ll√§ ja saatiin tulos aikaiseksi.
```javascript  


Teht√§ss√§ 1b etsit√§√§n/luetaan joka kolmas merkki mystinenSana joka tulee muutujaksi uusiMuuttuja. Jos merkki on "a" niin se muuttuu "*". Muuta merkkijono bold/uppercase-tyyliksi.

Tulostan teht√§v√§n tuloksen konsoliin ja testaan sek√§ committaan sen GitHubiin.

Pseudokoodi:

Tee alkuper√§inen merkkijono
Tee tyhj√§ merkkijono johon ker√§t√§√§n tulos

K√§y kaikki kirjaimet l√§pi
  Jos t√§m√§ on joka kolmas kirjain
    Jos kirjain on 'a'
      Lis√§√§ tulokseen '*'
    Muuten
      Lis√§√§ tulokseen t√§m√§ kirjain

Muuta tulos isoiksi kirjaimiksi
Tulosta tulos


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         20.5.2025     15.29           2826 README
-a----         19.5.2025     23.47            400 task1a-substring-search.js
-a----         20.5.2025     15.34            575 task1b-every-third-char.js
-a----         19.5.2025     13.00             56 task2a-age-validation.js
-a----         19.5.2025     13.00             47 task2b-age-loop.js
-a----         19.5.2025     13.00             42 task2c-age-switch.js
-a----         19.5.2025     13.00             46 task3-array-operations.js
-a----         19.5.2025     13.00             51 task4-flower-class.js
-a----         19.5.2025     13.00             43 task5-current-date.js
-a----         19.5.2025     13.00             49 task6-dom-text-insert.js
-a----         19.5.2025     13.00             47 task7-dom-table-insert.js


PS C:\Users\HP\javascript-1-7-harjoitussarja> node task1b-every-third-char.js
Origin string: asuntokionapajaa
Every 3 letter transformed: UOOP*


----------------


TEHT√ÑV√Ñ 2


Teht√§v√§ 2  Sy√∂tteen kysyminen ja ehdollinen toisto

Teht√§v√§n tavoite:

Pyyt√§√§ k√§ytt√§j√§lt√§ ik√§√§ niin kauan, kunnes se on v√§lill√§ 18-22

Kun ik√§ on v√§lill√§ 18-22, tulosta jotain i√§n perusteella

Pseudokoodi

1. Kysy k√§ytt√§j√§lt√§ ik√§ (k√§ytt√§en prompt-tyyppist√§ tapaa)

2. Toista niin kauan kunnes ik√§ on v√§lill√§ 18-22:
    - Jos ik√§ on liian pieni tai iso ‚Üí kysy uudelleen

3. Kun oikea ik√§ saatu:

    - Tarkista i√§n perusteella mit√§ tulostetaan:
      - Jos 18 ‚Üí nuori padawan
      - Jos 22 ‚Üí vanha viisas
      - Jne...

4. Tulosta ik√§ + sanallinen arvio



Testaus: 

PS C:\Users\HP\javascript-1-7-harjoitussarja> node task2a-age-validation.js

Set age between 18 - 22: 18
18 : Young Padawan üë∂

PS C:\Users\HP\javascript-1-7-harjoitussarja> node task2a-age-validation.js

set age between 18 - 22: 45
Invalid age, try again.
Set age between 18 - 22: 22
22 : Old üòä

PS C:\Users\HP\javascript-1-7-harjoitussarja> 



---------

Teht√§v√§ 3

 Teht√§v√§nm√§√§rittely: Task 3 ‚Äì Taulukon luonti, kopiointi, laajennus ja haku

a) Luo taulukko el√§imist√§
Luo taulukko, jossa on aluksi: "Dog", "Horse", "Cow"

Tulosta taulukko kokonaisuutena

Muunna taulukko merkkijonoksi k√§ytt√§en pilkkua

b) Kopioi alkuper√§inen taulukko
K√§yt√§ map()-metodia kopiointiin

Lis√§√§ uuteen taulukkoon kaksi uutta el√§int√§: "Cat", "Sheep"

c) Etsi sana "Cow" uudesta taulukosta
Etsi Cow uudesta taulukosta

Jos l√∂ytyy ‚Üí tulosta "Cow, Founded"

d) Testaa my√∂s sanalla jota ei ole
Kokeile esim. "CowS"

Jos ei l√∂ydy ‚Üí tulosta "CowS, Not founded"


PSEUDOKOODI

1. Luo alkuper√§inen taulukko:
   el√§imet = ["Dog", "Horse", "Cow"]
   Tulosta el√§imet
   Tulosta el√§imet merkkijonona pilkulla eroteltuna

2. Kopioi alkuper√§inen taulukko uuteen muuttujaan:
   uusiTaulukko = el√§imet.map jokainenEl√§in -> palauta jokainenEl√§in
   Lis√§√§ "Cat" ja "Sheep" uuteen taulukkoon

3. Hae "Cow" uudesta taulukosta:
   Jos uusiTaulukko sis√§lt√§√§ "Cow":
       Tulosta "Cow, Founded"
   Muuten:
       Tulosta "Cow, Not founded"

4. Testaa sana "CowS":
   Jos uusiTaulukko sis√§lt√§√§ "CowS":
       Tulosta "CowS, Founded"
   Muuten:
       Tulosta "CowS, Not founded"



  Testaus: 

Eli sain t√§m√§n vastukseksi:

"PS C:\Users\HP\javascript-1-7-harjoitussarja> node task3-array-operations.js 
Array: [ 'Dog', 'Horse', 'Cow' ]
ArrayStr: Dog,Horse,Cow
New array: [ 'Dog', 'Horse', 'Cow', 'Cat', 'Sheep' ]
Search result: Cow, Founded
Search result: CowS, Not founded

PS C:\Users\HP\javascript-1-7-harjoitussarja> "


-----------------------


Teht√§v√§ 4.

Define: Harjoituksen oppitavoitteet:

Ymm√§rt√§√§ olioiden rakentaminen ja muokkaaminen

Rakentaa metodirakenteita luokan sis√§lle

Tunnistaa perus- ja rakennepohjaiset muuttujat k√§yt√§nn√∂ss√§

Harjoitella datan esitt√§mist√§ toString()-funktion kautta


CLASS Flower
    METHOD constructor(type, color, amount, inStore)
        SET this.type = type
        SET this.color = color
        SET this.amount = amount
        SET this.inStore = inStore

    METHOD changeColor(newColor)
        SET this.color = newColor

    METHOD changeAmount(newAmount)
        SET this.amount = newAmount

    METHOD toggleInStore()
        SET this.inStore = NOT this.inStore

    METHOD toString()
        IF this.inStore IS true THEN
            SET storeStatus = "Yes"
        ELSE
            SET storeStatus = "No"
        ENDIF
        RETURN "Flower { Type: '" + this.type + "', Color: '" + this.color + "', Amount: " + this.amount + ", inStore: " + storeStatus + " }"

ENDCLASS

// USAGE
DECLARE myFlower = NEW Flower("Rose", "Red", 5, true)
PRINT myFlower.toString()

CALL myFlower.changeColor("Yellow")
CALL myFlower.changeAmount(3)
CALL myFlower.toggleInStore()

PRINT myFlower.toString()

Testaus:

PS C:\Users\HP\javascript-1-7-harjoitussarja> node task4-flower-class.js
1) After created: Flower { Type: 'Rose', Color: 'Red', Amount: 5, inStore: Yes }
2) After changed: Flower { Type: 'Rose', Color: 'Yellow', Amount: 3, inStore: No }
PS C:\Users\HP\javascript-1-7-harjoitussarja> 


----------------------

Teht√§v√§ 5

Teht√§v√§n kuvaus:


Kohta	          |           Miksi t√§rke√§

new Date()	    |      Luo p√§iv√§m√§√§r√§objektin

getDay()	      |      Palauttaa viikonp√§iv√§n numerona (0‚Äì6)

padStart(2, '0')|	    Lis√§√§ tarvittaessa etunollan esim.     
                |       kuukaudelle 1 ‚Üí 01

getMonth() + 1	|    Kuukaudet ovat 0‚Äì11 (tammi = 0)

Template literals	${...} tekee tekstist√§ helposti luettavaa



PSEUDOKOODI: 

1. CREATE a new Date object and store it in variable "today"

2. DEFINE an array "days" with weekday names:
   ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]

3. EXTRACT:
   - year from today using getFullYear()
   - month from today using getMonth(), add 1 to it (because it is zero-based)
   - day from today using getDate()
   - weekday number using getDay()

4. CONVERT month and day to 2-digit strings if necessary (e.g. 1 ‚Üí "01")

5. GET weekday name using: dayName = days[weekdayNumber]

6. FORMAT final string as:
   "Date: " + dayName + " " + year + "-" + month + "-" + day

7. PRINT the formatted string

TESTAUS;

PS C:\Users\HP\javascript-1-7-harjoitussarja> node task5-current-date.js

Date: Saturday 2025-05-24

PS C:\Users\HP\javascript-1-7-harjoitussarja> 

Omat "jorinat":

Olen rakentanut itselleni oman mallin nimelt√§ "Peruskivet 1‚Äì5", jonka avulla j√§senn√§n ohjelmoinnin taitoja ja teht√§vi√§ eri tasoihin.
T√§ss√§ mallissa jokainen kerros edustaa tietynlaista ajattelua ja rakenteen kompleksisuutta.

Taso 1: perustason muuttujat, kuten-> let temperature = 23.2;

Taso 2‚Äì3: ehtolauseet, silmukat ja rakenteet kuten listat ja objektit

Taso 4: funktiot ja modulaarisuus ‚Äì eli selke√§ lohkoajattelu ja uudelleenk√§ytett√§vyys

Taso 5: "tensorinen taso", jossa ohjelma alkaa tehd√§ p√§√§t√∂ksi√§ tilanteen tai datan perusteella (esim. p√§√§t√∂ksenteko eri viikonp√§ivien mukaan)

Tavoitteenani on jossain vaiheessa p√§√§st√§ kokeilemaan my√∂s kvanttilaskennan sovelluksia, joihin olen jo alkanut hankkia taustatietoa. T√§m√§ kerrosmalli auttaa minua hahmottamaan, miss√§ vaiheessa mik√§kin ajattelumalli on tarpeen ja miten koodi kehittyy yksinkertaisista rakenteista √§lykk√§√§ksi kokonaisuudeksi.

Ohessa kokeilin milt√§ n√§ytt√§isi t√§m√§ harjoitus 5.tason tensorisena teht√§v√§n√§ ja onhan se pirun hieno: 

const contexts = [
  { day: "Saturday", mood: "happy", theme: "üå∏ Weekend Chill Mode" },
  { day: "Monday", mood: "tired", theme: "‚òï Monday Grind" },
  { day: "Friday", mood: "excited", theme: "üéâ Friday Vibes" },
];

function getSmartTheme(dayName) {
  const match = contexts.find(c => c.day === dayName);
  return match ? match.theme : "üìÖ Normal Day";
}

function getTensorFormattedDate() {
  const today = new Date();
  const days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const dayName = days[today.getDay()];
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');

  const theme = getSmartTheme(dayName);
  return `${theme} ${dayName} ${year}-${month}-${day}`;
}

console.log(getTensorFormattedDate());


console.log(getSmartFormattedDate());


Mik√§ tekee t√§st√§ tensorisen ?


T√§m√§ koodi on ‚Äútensorinen‚Äù, koska se ei k√§yt√§ kovakoodattuja if/else-s√§√§nt√∂j√§ vaan tekee p√§√§t√∂ksen dynaamisesti rakenteesta, joka sis√§lt√§√§ useita ulottuvuuksia ‚Äì day, mood, theme ‚Äì ja k√§ytt√§√§ niiden yhdistelm√§√§ p√§√§t√∂ksenteon pohjana. P√§√§t√∂s ei siis perustu kovaan logiikkaan vaan dataan, joka voidaan helposti laajentaa, vaihtaa tai jopa korvata koneoppimismallilla, mik√§ tekee siit√§ skaalautuvan ja √§lykk√§√§n ‚Äì juuri kuten tensoriset rakenteet koneoppimisessa toimivat.



-------------------------------------

Tet√§v√§ 6.

Task 6
Define: Harjoituksen oppitavoitteet:

Ymm√§rt√§√§, miten JavaScriptill√§ voi muokata HTML-rakennetta (DOM)

Oppia k√§ytt√§m√§√§n document.querySelector ja appendChild -komentoja

Harjoitella tekstin luomista ja lis√§√§mist√§ HTML-elementteihin ohjelmallisesti

Hahmottaa, miten sivun rakenne ja JavaScript voivat yhdess√§ vaikuttaa n√§kyv√§√§n sis√§lt√∂√∂n.

Pseudokoodi

1. Hae HTML-sivulta <main>-elementti luokan perusteella
2. Luo uusi tekstisis√§lt√∂ (tekstisolmu) halutulla tekstill√§
3. Lis√§√§ t√§m√§ tekstisis√§lt√∂ <main>-elementin sis√§lle




